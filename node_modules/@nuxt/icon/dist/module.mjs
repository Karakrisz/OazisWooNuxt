import { isAbsolute, join, basename } from 'node:path';
import fs from 'node:fs/promises';
import { addVitePlugin, defineNuxtModule, createResolver, logger, addPlugin, addComponent, addServerHandler, addTemplate, hasNuxtModule } from '@nuxt/kit';
import { addCustomTab } from '@nuxt/devtools-kit';
import fg from 'fast-glob';
import { convertParsedSVG, parseSVGContent } from '@iconify/utils/lib/svg/parse';



// -- Unbuild CommonJS Shims --
import __cjs_url__ from 'url';
import __cjs_path__ from 'path';
import __cjs_mod__ from 'module';
const __filename = __cjs_url__.fileURLToPath(import.meta.url);
const __dirname = __cjs_path__.dirname(__filename);
const require = __cjs_mod__.createRequire(import.meta.url);
const collectionNames = [
  "academicons",
  "akar-icons",
  "ant-design",
  "arcticons",
  "basil",
  "bi",
  "bitcoin-icons",
  "bpmn",
  "brandico",
  "bx",
  "bxl",
  "bxs",
  "bytesize",
  "carbon",
  "cbi",
  "charm",
  "ci",
  "cib",
  "cif",
  "cil",
  "circle-flags",
  "circum",
  "clarity",
  "codicon",
  "covid",
  "cryptocurrency",
  "cryptocurrency-color",
  "dashicons",
  "devicon",
  "devicon-plain",
  "ei",
  "el",
  "emojione",
  "emojione-monotone",
  "emojione-v1",
  "entypo",
  "entypo-social",
  "eos-icons",
  "ep",
  "et",
  "eva",
  "f7",
  "fa",
  "fa-brands",
  "fa-regular",
  "fa-solid",
  "fa6-brands",
  "fa6-regular",
  "fa6-solid",
  "fad",
  "fe",
  "feather",
  "file-icons",
  "flag",
  "flagpack",
  "flat-color-icons",
  "flat-ui",
  "flowbite",
  "fluent",
  "fluent-emoji",
  "fluent-emoji-flat",
  "fluent-emoji-high-contrast",
  "fluent-mdl2",
  "fontelico",
  "fontisto",
  "formkit",
  "foundation",
  "fxemoji",
  "gala",
  "game-icons",
  "geo",
  "gg",
  "gis",
  "gravity-ui",
  "gridicons",
  "grommet-icons",
  "guidance",
  "healthicons",
  "heroicons",
  "heroicons-outline",
  "heroicons-solid",
  "humbleicons",
  "ic",
  "icomoon-free",
  "icon-park",
  "icon-park-outline",
  "icon-park-solid",
  "icon-park-twotone",
  "iconamoon",
  "iconoir",
  "icons8",
  "il",
  "ion",
  "iwwa",
  "jam",
  "la",
  "lets-icons",
  "line-md",
  "logos",
  "ls",
  "lucide",
  "mage",
  "majesticons",
  "maki",
  "map",
  "marketeq",
  "material-symbols",
  "material-symbols-light",
  "mdi",
  "mdi-light",
  "medical-icon",
  "memory",
  "meteocons",
  "mi",
  "mingcute",
  "mono-icons",
  "mynaui",
  "nimbus",
  "nonicons",
  "noto",
  "noto-v1",
  "octicon",
  "oi",
  "ooui",
  "openmoji",
  "oui",
  "pajamas",
  "pepicons",
  "pepicons-pencil",
  "pepicons-pop",
  "pepicons-print",
  "ph",
  "pixelarticons",
  "prime",
  "ps",
  "quill",
  "radix-icons",
  "raphael",
  "ri",
  "si-glyph",
  "simple-icons",
  "simple-line-icons",
  "skill-icons",
  "solar",
  "streamline",
  "streamline-emojis",
  "subway",
  "svg-spinners",
  "system-uicons",
  "tabler",
  "tdesign",
  "teenyicons",
  "token",
  "token-branded",
  "topcoat",
  "twemoji",
  "typcn",
  "uil",
  "uim",
  "uis",
  "uit",
  "uiw",
  "unjs",
  "vaadin",
  "vs",
  "vscode-icons",
  "websymbol",
  "whh",
  "wi",
  "wpf",
  "zmdi",
  "zondicons"
];

const schema = {
  $schema: {
    title: "Nuxt Icon",
    description: "Configure Nuxt Icon module preferences.",
    tags: ["@studioIcon material-symbols:star"]
  },
  size: {
    $default: void 0,
    $schema: {
      title: "Icon Size",
      description: "Set the default icon size.",
      tags: ["@studioIcon material-symbols:format-size-rounded"],
      tsType: "string | undefined"
    }
  },
  class: {
    $default: "",
    $schema: {
      title: "CSS Class",
      description: "Set the default CSS class.",
      tags: ["@studioIcon material-symbols:css"]
    }
  },
  attrs: {
    $default: {
      "aria-hidden": true
    },
    $schema: {
      title: "Default Attributes",
      description: [
        "Attributes applied to every icon component.",
        "",
        '@default { "aria-hidden": true }'
      ].join("\n"),
      tags: ["@studioIcon material-symbols:settings"],
      tsType: "Record<string, string | number | boolean>"
    }
  },
  mode: {
    $default: "css",
    $schema: {
      title: "Default Rendering Mode",
      description: "Set the default rendering mode for the icon component",
      enum: ["css", "svg"],
      tags: ["@studioIcon material-symbols:move-down-rounded"]
    }
  },
  aliases: {
    $default: {},
    $schema: {
      title: "Icon aliases",
      description: "Define Icon aliases to update them easily without code changes.",
      tags: ["@studioIcon material-symbols:star-rounded"],
      tsType: "{ [alias: string]: string }"
    }
  },
  cssSelectorPrefix: {
    $default: "i-",
    $schema: {
      title: "CSS Selector Prefix",
      description: "Set the default CSS selector prefix.",
      tags: ["@studioIcon material-symbols:format-textdirection-l-to-r"]
    }
  },
  cssLayer: {
    $default: void 0,
    $schema: {
      title: "CSS Layer Name",
      description: "Set the default CSS `@layer` name.",
      tags: ["@studioIcon material-symbols:layers"],
      tsType: "string | undefined"
    }
  },
  cssWherePseudo: {
    $default: true,
    $schema: {
      title: "Use CSS `:where()` Pseudo Selector",
      description: "Use CSS `:where()` pseudo selector to reduce specificity.",
      tags: ["@studioIcon material-symbols:low-priority"]
    }
  },
  collections: {
    $default: null,
    $schema: {
      title: "Icon Collections",
      description: [
        "List of known icon collections name. Used to resolve collection name ambiguity.",
        "e.g. `simple-icons-github` -> `simple-icons:github` instead of `simple:icons-github`",
        "",
        "When not provided, will use the full Iconify collection list."
      ].join("\n"),
      tags: ["@studioIcon material-symbols:format-list-bulleted"],
      tsType: "string[] | null"
    }
  },
  provider: {
    $default: void 0,
    $schema: {
      title: "Icon Provider",
      description: [
        "Provider to use for fetching icons",
        "",
        "- `server` - Fetch icons with a server handler",
        "- `iconify` - Fetch icons with Iconify API, purely client-side",
        "",
        "`server` by default; `iconify` when `ssr: false`"
      ].join("\n"),
      enum: ["server", "iconify"],
      tags: ["@studioIcon material-symbols:cloud"]
    }
  },
  iconifyApiEndpoint: {
    $default: "https://api.iconify.design",
    $schema: {
      title: "Iconify API Endpoint URL",
      description: "Define a custom Iconify API endpoint URL. Useful if you want to use a self-hosted Iconify API. Learn more: https://iconify.design/docs/api.",
      tags: ["@studioIcon material-symbols:api"]
    }
  },
  fallbackToApi: {
    $default: true,
    $schema: {
      title: "Fallback to Iconify API",
      description: "Fallback to Iconify API if server provider fails to found the collection.",
      tags: ["@studioIcon material-symbols:public"]
    }
  },
  localApiEndpoint: {
    $default: "/api/_nuxt_icon",
    $schema: {
      title: "Local API Endpoint Path",
      description: "Define a custom path for the local API endpoint.",
      tags: ["@studioIcon material-symbols:api"]
    }
  }
};

function unocssIntegration(nuxt, options) {
  let uno;
  function getKnownIconClasses() {
    const cache = uno?._cache;
    if (cache)
      return Array.from(cache.entries()).filter(([key, value]) => value && key.startsWith(options.cssSelectorPrefix || "i-")).map(([key]) => key);
    return [];
  }
  nuxt.hook("vite:configResolved", (config, { isClient }) => {
    if (!isClient)
      return;
    uno = config.plugins?.flat().find((p) => p && "name" in p && p.name === "unocss:api")?.api?.getContext?.()?.uno;
  });
  if (!nuxt.options.dev) {
    addVitePlugin(
      {
        name: "nuxt-icon:client-build-end",
        generateBundle() {
          if (uno) {
            options.serverKnownCssClasses ||= [];
            options.serverKnownCssClasses.push(...getKnownIconClasses());
          }
        }
      },
      { client: true, server: false }
    );
  }
  if (nuxt.options.dev) {
    nuxt.hook("nitro:init", async (_nitro) => {
      _nitro.options.runtimeConfig.icon ||= {};
      Object.defineProperty(_nitro.options.runtimeConfig.icon, "serverKnownCssClasses", {
        get() {
          return [
            ...options.serverKnownCssClasses || [],
            ...getKnownIconClasses()
          ];
        }
      });
    });
  }
}

const KEYWORDS_EDGE_TARGETS = [
  "edge",
  "cloudflare",
  "worker"
];
const module = defineNuxtModule({
  meta: {
    name: "@nuxt/icon",
    configKey: "icon",
    compatibility: {
      nuxt: ">=3.0.0"
    }
  },
  defaults: {
    // Module options
    componentName: "Icon",
    serverBundle: "auto",
    serverKnownCssClasses: [],
    // Runtime options
    provider: schema["provider"].$default,
    class: schema["class"].$default,
    size: schema["size"].$default,
    aliases: schema["aliases"].$default,
    iconifyApiEndpoint: schema["iconifyApiEndpoint"].$default,
    localApiEndpoint: schema["localApiEndpoint"].$default,
    fallbackToApi: schema["fallbackToApi"].$default,
    cssSelectorPrefix: schema["cssSelectorPrefix"].$default,
    cssWherePseudo: schema["cssWherePseudo"].$default,
    cssLayer: schema["cssLayer"].$default,
    mode: schema["mode"].$default,
    attrs: schema["attrs"].$default,
    collections: schema["collections"].$default
  },
  async setup(options, nuxt) {
    const resolver = createResolver(import.meta.url);
    if (!options.provider)
      options.provider = nuxt.options.ssr ? "server" : "client";
    let serverBundle = options.serverBundle;
    if (serverBundle === "auto") {
      serverBundle = nuxt.options.dev ? "local" : KEYWORDS_EDGE_TARGETS.some((word) => typeof nuxt.options.nitro.preset === "string" && nuxt.options.nitro.preset.includes(word)) ? "remote" : "local";
      logger.info(`Nuxt Icon server bundle mode is set to \`${serverBundle}\``);
    }
    addPlugin(
      resolver.resolve("./runtime/plugin")
    );
    addComponent({
      name: options.componentName || "Icon",
      global: true,
      filePath: resolver.resolve("./runtime/components/index")
    });
    addServerHandler({
      route: `${options.localApiEndpoint || "/api/_nuxt_icon"}/:collection`,
      handler: resolver.resolve("./runtime/server/api")
    });
    const runtimeOptions = Object.fromEntries(
      Object.entries(options).filter(([key]) => key in schema)
    );
    if (!runtimeOptions.collections) {
      runtimeOptions.collections = runtimeOptions.fallbackToApi ? collectionNames : typeof serverBundle === "string" ? collectionNames : serverBundle ? serverBundle.collections : [];
    }
    nuxt.options.appConfig.icon = Object.assign(
      nuxt.options.appConfig.icon || {},
      runtimeOptions
    );
    nuxt.hook("schema:extend", (schemas) => {
      schemas.push({
        appConfig: {
          icon: schema
        }
      });
    });
    const bundle = resolveServerBundle(
      nuxt,
      !serverBundle || options.provider !== "server" ? { disabled: true } : typeof serverBundle === "string" ? { remote: serverBundle === "remote" } : serverBundle,
      options.customCollections
    );
    const template = addTemplate({
      filename: "nuxt-icon-server-bundle.mjs",
      write: true,
      async getContents() {
        const {
          collections,
          remote
        } = await bundle;
        nuxt.options.appConfig.icon ||= {};
        const appIcons = nuxt.options.appConfig.icon;
        appIcons.collections ||= [];
        for (const collection of collections) {
          const prefix = typeof collection === "string" ? collection : collection.prefix;
          if (!appIcons.collections.includes(prefix))
            appIcons.collections.push(prefix);
        }
        const isBundling = !nuxt.options.dev;
        function getRemoteEndpoint(name) {
          if (typeof remote === "function")
            return remote(name);
          switch (remote) {
            case "jsdelivr":
              return `https://cdn.jsdelivr.net/npm/@iconify-json/${name}/icons.json`;
            case "unpkg":
              return `https://unpkg.com/@iconify-json/${name}/icons.json`;
            case "github-raw":
              return `https://raw.githubusercontent.com/iconify/icon-sets/master/json/${name}.json`;
            default:
              throw new Error(`Unknown remote collection source: ${remote}`);
          }
        }
        const collectionsValues = collections.map((collection) => {
          if (typeof collection === "string") {
            if (remote) {
              return `  '${collection}': createRemoteCollection(${JSON.stringify(getRemoteEndpoint(collection))}),`;
            }
            return isBundling ? `  '${collection}': () => import('@iconify-json/${collection}/icons.json', { with: { type: 'json' } }).then(m => m.default),` : `  '${collection}': () => require('@iconify-json/${collection}/icons.json'),`;
          } else {
            const { prefix } = collection;
            if ("fetchEndpoint" in collection)
              return `  '${prefix}': createRemoteCollection(${JSON.stringify(collection.fetchEndpoint)}),`;
            return `  '${prefix}': () => (${JSON.stringify(collection)}),`;
          }
        });
        const lines = [
          ...isBundling ? [] : [
            `import { createRequire } from 'module'`,
            `const require = createRequire(import.meta.url)`
          ],
          `function createRemoteCollection(fetchEndpoint) {`,
          "  let _cache",
          "  return async () => {",
          "    if (_cache)",
          "      return _cache",
          "    const res = await fetch(fetchEndpoint).then(r => r.json())",
          "    _cache = res",
          "    return res",
          "  }",
          "}",
          "",
          `export const collections = {`,
          ...collectionsValues,
          "}"
        ];
        return lines.join("\n");
      }
    });
    nuxt.options.nitro.alias ||= {};
    nuxt.options.nitro.alias["#nuxt-icon-server-bundle"] = template.dst;
    addCustomTab({
      name: "icones",
      title: "Ic\xF4nes",
      icon: "https://icones.js.org/favicon.svg",
      view: {
        type: "iframe",
        src: "https://icones.js.org"
      }
    });
    options.serverKnownCssClasses ||= [];
    const serverKnownCssClasses = options.serverKnownCssClasses || [];
    nuxt.options.runtimeConfig.icon = {
      serverKnownCssClasses
    };
    nuxt.hook("nitro:init", async (_nitro) => {
      _nitro.options.runtimeConfig.icon = {
        serverKnownCssClasses
      };
    });
    if (hasNuxtModule("@unocss/nuxt"))
      unocssIntegration(nuxt, options);
    await nuxt.callHook("icon:serverKnownCssClasses", serverKnownCssClasses);
  }
});
async function discoverLocalCollections() {
  const isPackageExists = await import('local-pkg').then((r) => r.isPackageExists);
  const collections = collectionNames.filter((collection) => isPackageExists("@iconify-json/" + collection));
  if (collections.length)
    logger.success(`Nuxt Icon discovered local-installed ${collections.length} collections:`, collections.join(", "));
  return collections;
}
async function resolveServerBundle(nuxt, options, customCollections = []) {
  const resolved = await options;
  if (resolved.disabled && customCollections.length)
    logger.warn("Nuxt Icon server bundle is disabled, the custom collections will not be bundled.");
  if (resolved.disabled) {
    return {
      disabled: true,
      remote: false,
      collections: []
    };
  }
  if (!resolved.collections)
    resolved.collections = resolved.remote ? collectionNames : await discoverLocalCollections();
  return {
    disabled: false,
    remote: resolved.remote === true ? "jsdelivr" : resolved.remote || false,
    collections: await Promise.all([
      ...resolved.collections || [],
      ...customCollections
    ].map((c) => resolveCollection(nuxt, c)))
  };
}
async function resolveCollection(nuxt, collection) {
  if (typeof collection === "string")
    return collection;
  if ("dir" in collection) {
    const dir = isAbsolute(collection.dir) ? collection.dir : join(nuxt.options.rootDir, collection.dir);
    const files = (await fg("*.svg", { cwd: dir, onlyFiles: true })).sort();
    const parsedIcons = await Promise.all(files.map(async (file) => {
      const name = basename(file, ".svg");
      let svg = await fs.readFile(join(dir, file), "utf-8");
      const cleanupIdx = svg.indexOf("<svg");
      if (cleanupIdx > 0)
        svg = svg.slice(cleanupIdx);
      const data = convertParsedSVG(parseSVGContent(svg));
      if (!data) {
        logger.error(`Nuxt Icon could not parse the SVG content for icon \`${name}\``);
        return [name, {}];
      }
      if (data.top === 0)
        delete data.top;
      if (data.left === 0)
        delete data.left;
      return [name, data];
    }));
    const successfulIcons = parsedIcons.filter(([_, data]) => Object.keys(data).length > 0);
    delete collection.dir;
    logger.success(`Nuxt Icon loaded local collection \`${collection.prefix}\` with ${successfulIcons.length} icons`);
    return {
      ...collection,
      icons: Object.fromEntries(successfulIcons)
    };
  }
  return collection;
}

export { module as default };
